# äº’è”ç½‘å®‰å…¨ æ¨è
| ts | title | url| 
| --- | --- | ---| 


# ç„æ­¦å®éªŒå®¤ æ¨è
| ts | title | url| 
| --- | --- | ---| 
| 20220406 | åŸºäº AR è®¾å¤‡ä¸­è‚Œç”µå›¾ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆEMGï¼‰çš„ Keylogging ä¾§ä¿¡é“æ”»å‡» | https://tuprints.ulb.tu-darmstadt.de/20660/1/myo_paper.pdf| 
| 20220406 | Fuzzing Like A Caveman 6: Binary Only Snapshot Fuzzing Harness | https://h0mbre.github.io/Fuzzing-Like-A-Caveman-6/| 
| 20220406 | Breaking SecureBoot With SMM | https://www.youtube.com/watch?v=ge_TnLfTv8I| 
| 20220406 | å¼€æºä¼ä¸šçº§ VPN - Pritunl çš„ Client è¢«å‘ç°æœ¬åœ°ææƒæ¼æ´ | https://rhinosecuritylabs.com/penetration-testing/cve-2022-25372-local-privilege-escalation-in-pritunl-vpn-client/| 
| 20220406 | Windows çš„ KUSER_SHARED_DATA ç»“æ„ä½“è¦æ”¯æŒ ASLR äº† | https://msrc-blog.microsoft.com/2022/04/05/randomizing-the-kuser_shared_data-structure-on-windows/| 
| 20220406 | Performing and Preventing Attacks on Azure Cloud Environments through Azure DevOps | http://labs.f-secure.com/blog/performing-and-preventing-attacks-on-azure-cloud-environments-through-azure-devops/| 
| 20220406 | Frida Internal - Part 1: æ¶æ„ã€Gum ä¸ V8 | http://evilpan.com/2022/04/05/frida-internal/| 
| 20220406 | macOS SUHelper root æœ¬åœ°ææƒæ¼æ´åˆ†æï¼ˆCVE-2022-22639ï¼‰ | https://www.trendmicro.com/en_us/research/22/d/macos-suhelper-root-privilege-escalation-vulnerability-a-deep-di.html| 
| 20220406 | åˆ©ç”¨ PE æ–‡ä»¶ä¸­çš„ç‰¹æ®Š Sections å‘ç›®æ ‡è¿›ç¨‹æ³¨å…¥ä»»æ„ shellcode | https://billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/| 
| 20220406 | æºç å±‚é¢æ¢³ç†Java RMIäº¤äº’æµç¨‹ | https://tttang.com/archive/1530/| 
| 20220403 | IETF 113çº¿ä¸Šä¼šè®®èµ„æ–™ã€‚ | https://theinternetprotocolblog.wordpress.com/2022/03/30/ietf-113/| 
| 20220403 | æ½œè—åœ¨é£å¹³æµªé™ä¸­çš„æ³¢æ¾œâ€”â€”APT-C-00æµ·è²èŠ±ç»„ç»‡æ”»å‡»æ´»åŠ¨åŠ¨æ€æµ…æ | https://mp.weixin.qq.com/s/tBQSbv55lJUipaPWFr1fKw| 
| 20220402 | Rockwell PLC è¢«å‘ç°è¿œç¨‹é«˜å±æ¼æ´ | https://thehackernews.com/2022/04/critical-bugs-in-rockwell-plc-could.html| 
| 20220402 | Linux å†…æ ¸ netfilter å­ç³»ç»Ÿ nf_tables CVE-2022-1015/CVE-2022-1016 æ¼æ´åˆ†æ | https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/| 
| 20220402 | On the Naturalness of Fuzzer-Generated Code | http://rohan.padhye.org/files/natfuzz-msr22.pdf| 
| 20220402 | Microsoft Defender for Endpoint çš„è°ƒè¯•æ–¹æ³•ä»¥åŠèº«ä»½ä¼ªé€ æ¼æ´åˆ†æ | https://medium.com/falconforce/debugging-the-undebuggable-and-finding-a-cve-in-microsoft-defender-for-endpoint-ce36f50bb31| 
| 20220402 | Go è¯­è¨€å°†åº”ç”¨æ–° Mitigation é˜²å¾¡ä¾›åº”é“¾æ”»å‡» | https://go.dev/blog/supply-chain| 
| 20220402 | PHP Supply Chain Attack on PEAR | https://blog.sonarsource.com/php-supply-chain-attack-on-pear/| 
| 20220402 | ç”¨äºæµ‹è¯• SSH ä¸­é—´äººåŠ«æŒçš„å·¥å…· | https://github.com/ssh-mitm/ssh-mitm/blob/master/README.md| 
| 20220402 | Austin Pwn2Own æ¯”èµ›åˆ©ç”¨ 4 ä¸ªæ¼æ´å®ç° Cisco RV340 RCE çš„ç»†èŠ‚ | https://blog.relyze.com/2022/04/pwning-cisco-rv340-with-4-bug-chain.html| 


# å®‰å…¨ç»´åŸº æ¨è
| ts | title | url| 
| --- | --- | ---| 
| 20220407 | å…ƒå®‡å®™ä¸å›½å®¶æ•°æ®å®‰å…¨ï¼šæ„å»ºç”Ÿæ€åŒ–æ²»ç†ä½“ç³»çš„æŒ‘æˆ˜ä¸è¶‹åŠ¿ | https://mp.weixin.qq.com/s/9ZFhKumGOYfNU7Tv8zY59g| 
| 20220406 | MITRE ATT&CK ç¬¬å››è½®è¯„ä¼°ç»“æœå‘å¸ƒ | https://mp.weixin.qq.com/s/j6IuqWNXqon_hVLUH6blVA| 
| 20220406 | What is DQ ODN? | /topic/88| 
| 20220406 | æ— äººæœºMAVLINKåè®®å®‰å…¨å‰–æ | http://mp.weixin.qq.com/s/WEivJpxTBSVcmAa5QvvDxQ| 
| 20220406 | Netgear R8300æ ˆæº¢å‡ºæ¼æ´åˆ†æ | http://mp.weixin.qq.com/s/xxOwRRDg-n4_rXY8c50SdQ| 
| 20220404 | SecWikiå‘¨åˆŠï¼ˆç¬¬422æœŸ) | https://www.sec-wiki.com/weekly/422| 
| 20220404 | CDNåŠç‰¹å¾éšåŒ¿Cobalt Strike | https://xz.aliyun.com/t/11099| 
| 20220404 | å¯¹äºæŒ–çŸ¿çš„æ£€æµ‹ä»¥åŠé˜²å¾¡æ–¹æ¡ˆ | https://xz.aliyun.com/t/11102| 
| 20220404 | Generate all call graph for Java Code | https://github.com/Adrninistrator/java-all-call-graph| 
| 20220403 | ä»DARPAé¡¹ç›®å­¦ä¹ å¦‚ä½•åšå®‰å…¨ç ”ç©¶ | https://mp.weixin.qq.com/s/BkOIosI50NRqzz8Vsbm1Hg| 


# CVE Github æ¨è
| ts | cve_id | title | url | cve_detail| 
| --- | --- | --- | --- | ---| 
| 20220407T12:22:44Z | CVE-2022-22965 | Spring Framework RCE (CVE-2022-22965) Nmap (NSE) Checker (Non-Intrusive) | https://github.com/alt3kx/CVE-2022-22965 | | 
| 20220407T07:41:39Z | CVE-2020-14381 | Null | https://github.com/nanopathi/linux-4.19.72_CVE-2020-14381 | | 
| 20220407T02:32:46Z | CVE-2022-22965 | CVE-2022-22965 pocsuite3 POC | https://github.com/wikiZ/springboot_CVE-2022-22965 | | 
| 20220407T01:52:17Z | CVE-2022-26631 | CVE-2022-26631 - Automatic Question Paper Generator v1.0 SQLi | https://github.com/Cyb3rR3ap3r/CVE-2022-26631 | | 
| 20220406T21:20:38Z | CVE-2022-28113 | Unauthenticated RCE exploit for Fantec MWiD25-DS | https://github.com/code-byter/CVE-2022-28113 | | 
| 20220406T21:18:43Z | CVE-2022-22965 | Vulnerabilidad RCE en Spring Framework vÃ­a Data Binding on JDK 9+ | https://github.com/GuayoyoCyber/CVE-2022-22965 | | 
| 20220406T20:12:07Z | cve-2022-22965 | Null | https://github.com/irgoncalves/irule-cve-2022-22965 | | 
| 20220406T16:31:14Z | CVE-2022-23909 | Unquoted Service Path privilege escalation vulnerability in Sherpa Connector Service.  | https://github.com/netsectuna/CVE-2022-23909 | | 
| 20220406T15:14:26Z | CVE-2021-22555 | CVE-2021-22555 exploit rewritten with pipe primitive | https://github.com/veritas501/CVE-2021-22555-PipeVersion | | 
| 20220406T14:54:12Z | cve-2021-41773 | Null | https://github.com/vuongnv3389-sec/cve-2021-41773 | | 


# klee on Github æ¨è
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220407T12:42:57Z | An open-source Chinese font derived from Fontworks% Klee One. ä¸€æ¬¾å¼€æºä¸­æ–‡å­—ä½“ï¼ŒåŸºäº FONTWORKS å‡ºå“å­—ä½“ Klee One è¡ç”Ÿã€‚   | https://github.com/lxgw/LxgwWenKai | 5680 | 210| 
| 20220407T10:16:31Z | KLEE Symbolic Execution Engine | https://github.com/klee/klee | 1938 | 550| 
| 20220407T07:06:38Z | kleenway-client | https://github.com/hidemydreams/kleenway-client | 0 | 0| 
| 20220407T05:04:07Z | Null | https://github.com/youfantan/KleeBot | 2 | 0| 
| 20220407T03:41:44Z | TracerX Symbolic Virtual Machine | https://github.com/tracer-x/TracerX | 17 | 9| 
| 20220406T11:10:00Z | This font is based on the font Klee One by Fontworks, and the font LXGW WenKai by LXGW for adding Simplified and Traditional Chinese character glyphs. The pinyin characters are added by ToneOZ.com using the open source tool Mengshen, with the IVS heteronyms font concept from the Bopomofo IVS by But Ko. | https://github.com/jeffreyxuan/toneoz-font-pinyin-wenkai | 18 | 1| 
| 20220406T10:01:57Z | Symbiotic is a tool for finding bugs in computer programs based on instrumentation, program slicing and KLEE | https://github.com/staticafi/symbiotic | 232 | 38| 
| 20220405T21:46:09Z | Null | https://github.com/DeviRule/klee_test | 0 | 0| 
| 20220405T12:45:37Z | Imagine you could pick up a fragment of code in a complex system written in C and test it in separation on your Linux workstation without the burden of including all necessary headers and knowing the right set of #defines, compilation flags and the target architecture. Imagine you could use that code in a modern fuzzer or symbolic execution engine for thorough, focused deep testing.  AoT makes it possible to select a function from C code base and generate an executable off-target test harness. The harness can then be tested on a Linux machine, e.g. with ASAN, AFL or KLEE. The generated off-target is a self-contained binary and includes all the necessary types and definitions. In a nutshell, AoT makes it possible to test pieces of complex systems software in a unit test-like manner. What it is and how does this work?  First, you select a function F you are interested to test. AoT uses Code Aware Services (CAS) infrastructure, namely code database and compilation database to automatically pull in a subtree of functions called by F (that is, functions that F calls, functions that they call, etc.). By default, AoT stops at the module boundary: the functions compiled into the same module as F are pulled in, all the others are left out. For the functions that are left out AoT generates function stubs which can later be filled by the user. Such generated program is called an off-target, because it runs off the original code execution environment (e.g. a smartphone).  AoT works well with the AFL fuzzer (https://lcamtuf.coredump.cx/afl/) and the KLEE symbolic execution engine (http://klee.github.io/). It automatically generates binaries and test setup for those tools, so that you can start fuzzing the off-target immediately.  AoT is an automated solution that currently works in the human-in-the-loop model. It means that AoT tries to automate as much as possible, but a human operator is needed to fine-tune the results - e.g. provide stubs implementation or correct the program state initialization.  Potential uses of AoT are:      get a recursive list of functions given an entry point (could be used to get selective coverage)     get a list of types necessary for a given piece of code     instrument code for inter-structure fuzzing (unsupported yet)     instrument code for fuzzing / symbolic execution and apply those techiques to complex systems code     speed up development for slowly building targets (e.g. AOSP build process)  For example, let%s imagine we would like to test a message parser in a mobile phone modem. Normally, for such testing we need to set up the physical infrastructure, for example a base station that sends messages over the air to the mobile phone. When the message is received by the phone, the parser code is invoked. If there is an error, we need to collect potential crash logs (if any) and restart testing. The whole process is difficult to set up and a single testing cycle takes quite long. With AoT things look differently. We select the message parsing function as our target. AoT automatically pulls in the necessary definitions and functions compiled into the same module and generates function stubs for the functions outside of the module. Moreover, AoT generates the program state initialization and the code necessary for starting security fuzzing. The generated off-target code is self contained - we can compile it on a Linux box and use all standard tools such as fuzzers, gdb, sanitizers to test the code. As a result, we end up with a much faster setup and test cycle: the off-target generation takes minutes and we can re-execute the code up to thousands of times per minute. We can also easily attach a debugger and quickly inspect what went wrong.  As a further example let%s take the last point and let%s imagine we are modifying an AOSP kernel driver. Without AoT, we need to invoke entire build process to check if our change is correct. Moreover, we would need to run the code in an Android emulator or on the phone and find a way to invoke the changed driver code (which sometimes is not trivial). With AoT we can extract the code of the changed function and compile it within minutes. We can further use all available x86_64 Linux toolchains (gdb, sanitizers, etc.) to test it. As a result, the development & testing cycle should be much shorter. | https://github.com/Samsung/auto_off_target | 1 | 0| 
| 20220405T08:38:50Z | A concolic testing framework for RISC-V embedded software with support for SystemC peripherals | https://github.com/agra-uni-bremen/symex-vp | 6 | 1| 


# s2e on Github æ¨è
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220407T09:05:46Z | ğŸš CRAX++: Modular exploit generator using symbolic execution | https://github.com/SQLab/CRAXplusplus | 40 | 3| 
| 20220403T15:27:07Z | Null | https://github.com/wqewqfdas/s2edsa | 0 | 0| 
| 20220403T10:01:51Z | Null | https://github.com/s2eung1/s2eung1 | 0 | 0| 
| 20220402T21:47:27Z | Documents for Spacecraft Simulation Environment | https://github.com/ut-issl/s2e-documents | 3 | 3| 
| 20220402T17:57:18Z | Null | https://github.com/software-testing-bootcamp/S2E4-API-Test-Karate-Gatling | 0 | 0| 


# exploit on Github æ¨è
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220407T12:40:52Z | Trojan Rat Builder(348), Ransomware Builder(17), Crypter(110), Miner(9), Worm(8), Botnet(49), Virus Builder(62), Binder(35), Exploit(42), Keylogger & Stealer(40), Proxy Tool(30), Spoofer(12),Fake program & Sample Virus(64), GSM Box(), CEH Pack(34) & Many Mores. Around ğŸ,ğŸ“ğŸ”ğŸ tools, that you can use for Hacking. | https://github.com/Dankaminsk/GH-Hacking-Tool-Kit | 0 | 0| 
| 20220407T12:39:14Z | Trojan Rat Builder(310), Ransomware Builder(17), Crypter(72), Miner(9), Worm(8), Botnet(25), Virus Builder(9), Binder(25), Exploit(7), Keylogger & Stealer(40), Proxy Tool(9), Spoofer(11),Fake program & Sample Virus(64),Other & Tools(16). Around ğŸ”ğŸ‘ğŸ tools, that you can use for Hacking. | https://github.com/Dankaminsk/Hacking-Tools-Pack | 0 | 0| 
| 20220407T12:24:22Z | Trojan Rat Builder(348), Ransomware Builder(17), Crypter(110), Miner(9), Worm(8), Botnet(49), Virus Builder(62), Binder(35), Exploit(42), Keylogger & Stealer(40), Proxy Tool(30), Spoofer(12),Fake program & Sample Virus(64), GSM Box(), CEH Pack(34) & Many Mores. Around ğŸ,ğŸ“ğŸ”ğŸ tools, that you can use for Hacking. | https://github.com/Whispers00/GH-Hacking-Tool-Kit | 0 | 0| 
| 20220407T12:23:47Z | Open Source Exploit For Roblox | https://github.com/M02java/Ice-Exploit | 0 | 0| 
| 20220407T12:20:30Z | Trojan Rat Builder(310), Ransomware Builder(17), Crypter(72), Miner(9), Worm(8), Botnet(25), Virus Builder(9), Binder(25), Exploit(7), Keylogger & Stealer(40), Proxy Tool(9), Spoofer(11),Fake program & Sample Virus(64),Other & Tools(16). Around ğŸ”ğŸ‘ğŸ tools, that you can use for Hacking. | https://github.com/Whispers00/Hacking-Tools-Pack | 0 | 0| 
| 20220407T12:09:24Z | Trojan Rat Builder(348), Ransomware Builder(17), Crypter(110), Miner(9), Worm(8), Botnet(49), Virus Builder(62), Binder(35), Exploit(42), Keylogger & Stealer(40), Proxy Tool(30), Spoofer(12),Fake program & Sample Virus(64), GSM Box(), CEH Pack(34) & Many Mores. Around ğŸ,ğŸ“ğŸ”ğŸ tools, that you can use for Hacking. | https://github.com/Hackeroffice00/GH-Hacking-Tool-Kit | 0 | 0| 
| 20220407T12:05:18Z | Trojan Rat Builder(310), Ransomware Builder(17), Crypter(72), Miner(9), Worm(8), Botnet(25), Virus Builder(9), Binder(25), Exploit(7), Keylogger & Stealer(40), Proxy Tool(9), Spoofer(11),Fake program & Sample Virus(64),Other & Tools(16). Around ğŸ”ğŸ‘ğŸ tools, that you can use for Hacking. | https://github.com/Hackeroffice00/Hacking-Tools-Pack | 0 | 0| 
| 20220407T11:37:34Z | Trojan Rat Builder(348), Ransomware Builder(17), Crypter(110), Miner(9), Worm(8), Botnet(49), Virus Builder(62), Binder(35), Exploit(42), Keylogger & Stealer(40), Proxy Tool(30), Spoofer(12),Fake program & Sample Virus(64), GSM Box(), CEH Pack(34) & Many Mores. Around ğŸ,ğŸ“ğŸ”ğŸ tools, that you can use for Hacking. | https://github.com/Guccifer00/GH-Hacking-Tool-Kit | 0 | 0| 
| 20220407T11:35:04Z | A simplified and effective version of IPO (called SIPO) with the aim of simplifying the main IPO equations, creating a powerful trade-off between the concepts of exploitation and exploration, and modifying the complexity of their structural parameters. | https://github.com/ali-ece/A-Simplified-and-Efficient-Version-of-Inclined-Planes-system-Optimization-SIPO-Algorithm | 0 | 0| 
| 20220407T11:34:21Z | Trojan Rat Builder(310), Ransomware Builder(17), Crypter(72), Miner(9), Worm(8), Botnet(25), Virus Builder(9), Binder(25), Exploit(7), Keylogger & Stealer(40), Proxy Tool(9), Spoofer(11),Fake program & Sample Virus(64),Other & Tools(16). Around ğŸ”ğŸ‘ğŸ tools, that you can use for Hacking. | https://github.com/Guccifer00/Hacking-Tools-Pack | 0 | 0| 


# backdoor on Github æ¨è
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220407T12:39:48Z | Linux eBPF backdoor over TCP. Spawn reverse shells, RCE, on prior privileged access. Less Honkin, More Tonkin. | https://github.com/kris-nova/boopkit | 498 | 42| 
| 20220407T09:01:38Z | Wordpress backdoor creation plugin | https://github.com/alexrod94/wordpress-security | 0 | 0| 
| 20220406T12:21:43Z | AV evading OSX Backdoor and Crypter Framework | https://github.com/SubGlitch1/OSRipper | 33 | 6| 
| 20220406T11:35:15Z | personal usage | https://github.com/ThebestkillerTBK/BackdoorPlugin | 0 | 0| 
| 20220405T20:37:03Z | plugin designed for mc.newfag.ru that includes very bad-coded but strong backdoor | https://github.com/maywr/NewFagPlugin | 0 | 0| 
| 20220405T20:22:58Z | backdoor thats sends info through a server to the attacker | https://github.com/3BixxPy/PythonBackdoor | 0 | 0| 
| 20220405T18:55:51Z | This is the implementation for CVPR 2022 Oral paper %Better Trigger Inversion Optimization in Backdoor Scanning.% | https://github.com/Gwinhen/PixelBackdoor | 1 | 0| 
| 20220405T14:54:12Z | Simple Backdoor written in C  | https://github.com/TsuNIIII/watchingEye-backdoor | 0 | 0| 
| 20220405T12:26:04Z | Windows backdoor that will be registered and melted to the registry and embedded to the startup and is scanned to undetectable by 32 anti-virus :p  | https://github.com/NetM0nDevs/Winddows-Backdoor-B- | 0 | 0| 
| 20220405T08:22:16Z | Config files for my GitHub profile. | https://github.com/backdoorPhish/backdoorPhish | 0 | 0| 


# symbolic execution on Github æ¨è
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220407T11:11:15Z | The symbolic execution engine powering the K Framework | https://github.com/runtimeverification/haskell-backend | 173 | 36| 
| 20220407T10:16:31Z | KLEE Symbolic Execution Engine | https://github.com/klee/klee | 1938 | 550| 
| 20220407T09:05:46Z | ğŸš CRAX++: Modular exploit generator using symbolic execution | https://github.com/SQLab/CRAXplusplus | 40 | 3| 
| 20220407T07:31:33Z | Playing with the VMProtect software protection. Automatic deobfuscation of pure functions using symbolic execution and LLVM. | https://github.com/JonathanSalwan/VMProtect-devirtualization | 532 | 94| 
| 20220407T07:28:17Z | radius2 is a fast binary emulation and symbolic execution framework using radare2 | https://github.com/aemmitt-ns/radius | 216 | 15| 
| 20220407T02:18:38Z | Angora is a mutation-based fuzzer.  The main goal of Angora is to increase branch coverage by solving path constraints without symbolic execution.  | https://github.com/AngoraFuzzer/Angora | 771 | 146| 
| 20220407T01:34:04Z | A small RISC-V symbolic execution engine | https://github.com/zyedidia/rvsym | 2 | 0| 
| 20220407T01:05:01Z | symbolic execution for x86 | https://github.com/ZicoChan2003/bniemczykc | 0 | 0| 
| 20220405T16:44:43Z | Slides and Material for %SymbolicExecutionDemystified% Presentation @ Insomni%Hack 2022 | https://github.com/JannisKirschner/SymbolicExecutionDemystified | 82 | 14| 
| 20220405T12:45:37Z | Imagine you could pick up a fragment of code in a complex system written in C and test it in separation on your Linux workstation without the burden of including all necessary headers and knowing the right set of #defines, compilation flags and the target architecture. Imagine you could use that code in a modern fuzzer or symbolic execution engine for thorough, focused deep testing.  AoT makes it possible to select a function from C code base and generate an executable off-target test harness. The harness can then be tested on a Linux machine, e.g. with ASAN, AFL or KLEE. The generated off-target is a self-contained binary and includes all the necessary types and definitions. In a nutshell, AoT makes it possible to test pieces of complex systems software in a unit test-like manner. What it is and how does this work?  First, you select a function F you are interested to test. AoT uses Code Aware Services (CAS) infrastructure, namely code database and compilation database to automatically pull in a subtree of functions called by F (that is, functions that F calls, functions that they call, etc.). By default, AoT stops at the module boundary: the functions compiled into the same module as F are pulled in, all the others are left out. For the functions that are left out AoT generates function stubs which can later be filled by the user. Such generated program is called an off-target, because it runs off the original code execution environment (e.g. a smartphone).  AoT works well with the AFL fuzzer (https://lcamtuf.coredump.cx/afl/) and the KLEE symbolic execution engine (http://klee.github.io/). It automatically generates binaries and test setup for those tools, so that you can start fuzzing the off-target immediately.  AoT is an automated solution that currently works in the human-in-the-loop model. It means that AoT tries to automate as much as possible, but a human operator is needed to fine-tune the results - e.g. provide stubs implementation or correct the program state initialization.  Potential uses of AoT are:      get a recursive list of functions given an entry point (could be used to get selective coverage)     get a list of types necessary for a given piece of code     instrument code for inter-structure fuzzing (unsupported yet)     instrument code for fuzzing / symbolic execution and apply those techiques to complex systems code     speed up development for slowly building targets (e.g. AOSP build process)  For example, let%s imagine we would like to test a message parser in a mobile phone modem. Normally, for such testing we need to set up the physical infrastructure, for example a base station that sends messages over the air to the mobile phone. When the message is received by the phone, the parser code is invoked. If there is an error, we need to collect potential crash logs (if any) and restart testing. The whole process is difficult to set up and a single testing cycle takes quite long. With AoT things look differently. We select the message parsing function as our target. AoT automatically pulls in the necessary definitions and functions compiled into the same module and generates function stubs for the functions outside of the module. Moreover, AoT generates the program state initialization and the code necessary for starting security fuzzing. The generated off-target code is self contained - we can compile it on a Linux box and use all standard tools such as fuzzers, gdb, sanitizers to test the code. As a result, we end up with a much faster setup and test cycle: the off-target generation takes minutes and we can re-execute the code up to thousands of times per minute. We can also easily attach a debugger and quickly inspect what went wrong.  As a further example let%s take the last point and let%s imagine we are modifying an AOSP kernel driver. Without AoT, we need to invoke entire build process to check if our change is correct. Moreover, we would need to run the code in an Android emulator or on the phone and find a way to invoke the changed driver code (which sometimes is not trivial). With AoT we can extract the code of the changed function and compile it within minutes. We can further use all available x86_64 Linux toolchains (gdb, sanitizers, etc.) to test it. As a result, the development & testing cycle should be much shorter. | https://github.com/Samsung/auto_off_target | 1 | 0| 


# big4 on Github æ¨è
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220406T15:56:31Z | Code for NDSS 2022 paper %MIRROR: Model Inversion for Deep Learning Network with High Fidelity% | https://github.com/njuaplusplus/mirror | 3 | 0| 


# fuzz on Github æ¨è
| ts | title | url | stars | forks| 
| --- | --- | --- | --- | ---| 
| 20220407T11:36:09Z | OSS-Fuzz - continuous fuzzing for open source software. | https://github.com/google/oss-fuzz | 7229 | 1543| 
| 20220407T11:30:22Z | Null | https://github.com/Eson-Jia/fuzz-tutorial | 0 | 0| 
| 20220407T10:48:04Z | A list of word lists that I use for fuzzing sometimes.  | https://github.com/cornerpirate/pentestingLists | 0 | 0| 
| 20220407T10:11:55Z | Full-featured test framework for Go! Assertions, fuzzing, input testing, output capturing, and much more! ğŸ• | https://github.com/MarvinJWendt/testza | 380 | 16| 
| 20220407T01:27:48Z | Null | https://github.com/Noxizal/fuzzy-winner | 0 | 0| 
| 20220407T01:12:34Z | fuzzy logic in Python | https://github.com/MatthewNielsen27/fuzzy | 0 | 0| 
| 20220407T00:59:02Z | Project develop in angular with .NET | https://github.com/JulianMontu/fuzzy-invention | 0 | 0| 
| 20220407T00:10:21Z | fuzz | https://github.com/LMS57/solar_fuzz | 0 | 0| 
| 20220406T22:55:09Z | Null | https://github.com/Kaine1145/fuzzy-octo-waddle | 0 | 0| 
| 20220406T21:16:02Z | Null | https://github.com/brwhitsett/FuzzyWhatzies_frontend_REACT | 0 | 0| 



# æ—¥æ›´æ–°ç¨‹åº
